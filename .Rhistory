guide = guide_legend(reverse = TRUE)) +
labs(title = "Distribution of Rental Prices per sqm across GVBs (2021)",
x = "Price per sqm (€)",
y = "Number of GVBs") +
theme_minimal(base_size = 14) +
theme(panel.grid.minor = element_blank(),
legend.position = "right")
summary(rent_data)
# 2. Basic histogram
ggplot(rent_data, aes(x = price_qm2023)) +
geom_histogram(binwidth = 100, fill = "steelblue", color = "white") +
labs(title = "Distribution of Rental Prices per sqm across GVBs (2023)",
x = "Price per sqm (€)",
y = "Number of GVBs") +
theme_minimal(base_size = 14) +
theme(panel.grid.minor = element_blank())
# 3. Plot histogram with binwidth but fill determined by price_bin intervals
ggplot(rent_data, aes(x = price_qm2023, fill = price_bin)) +
geom_histogram(binwidth = 100, boundary = 0, closed = "left") +
scale_fill_manual(name = "€ per sqm", values = magma_colors, drop = FALSE,
guide = guide_legend(reverse = TRUE)) +
scale_x_continuous(breaks = seq(0, max(rent_data$price_qm2023, na.rm = TRUE), by = 1000)) +
labs(title = "Distribution of Rental Prices per sqm across GVBs (2021)",
x = "Price per sqm (€)",
y = "Number of GVBs") +
theme_minimal(base_size = 14) +
theme(panel.grid.minor = element_blank(),
legend.position = "right")
# 1. Define your bins and magma colors
bin_breaks <- c(500, 1000, 2000, 3000, 4000, 5000, 6000, 8000, 10000, Inf)
bin_labels <- c("500–1000", "1000-2000", "2000-3000", "3000-4000",
"4000-5000", "5000-6000", "6000-8000", "8000-10000",
"10000+")
viridis_colors <- viridis(10, direction = -1)
names(viridis_colors) <- bin_labels
# 2. Classify observations into bins
rent_data <- rent_data %>%
mutate(price_bin = cut(price_qm2023, breaks = bin_breaks, labels = bin_labels, right = FALSE))
# 3. Plot histogram with binwidth but fill determined by price_bin intervals
ggplot(rent_data, aes(x = price_qm2023, fill = price_bin)) +
geom_histogram(binwidth = 100, boundary = 0, closed = "left") +
scale_fill_manual(name = "€ per sqm", values = viridis_colors, drop = FALSE,
guide = guide_legend(reverse = TRUE)) +
scale_x_continuous(breaks = seq(0, max(rent_data$price_qm2023, na.rm = TRUE), by = 1000)) +
labs(title = "Distribution of Rental Prices per sqm across GVBs (2021)",
x = "Price per sqm (€)",
y = "Number of GVBs") +
theme_minimal(base_size = 14) +
theme(panel.grid.minor = element_blank(),
legend.position = "right")
# 3. Plot histogram with binwidth but fill determined by price_bin intervals
ggplot(rent_data, aes(x = price_qm2023, fill = price_bin)) +
geom_histogram(binwidth = 100, boundary = 0, closed = "left") +
scale_fill_manual(name = "€ per sqm", values = viridis_colors, drop = FALSE,
guide = guide_legend(reverse = TRUE)) +
scale_x_continuous(breaks = seq(0, max(rent_data$price_qm2023, na.rm = TRUE), by = 1000)) +
labs(title = "Distribution of Rental Prices per sqm across GVBs (2021)",
x = "Price per sqm (€)",
y = "Number of GVBs") +
theme_minimal(base_size = 14) +
theme(panel.grid.minor = element_blank(),
legend.position = "right")
# 3. Plot histogram with binwidth but fill determined by price_bin intervals
ggplot(rent_data, aes(x = price_qm2023, fill = price_bin)) +
geom_histogram(binwidth = 100, boundary = 0, closed = "left") +
scale_fill_manual(name = "€ per sqm", values = viridis_colors, drop = FALSE,
guide = guide_legend(reverse = TRUE)) +
scale_x_continuous(breaks = seq(0, max(rent_data$price_qm2023, na.rm = TRUE), by = 1000)) +
labs(title = "Distribution of Rental Prices per sqm across GVBs (2023)",
x = "Price per sqm (€)",
y = "Number of GVBs") +
theme_minimal(base_size = 14) +
theme(panel.grid.minor = element_blank(),
legend.position = "right")
# 3. Plot histogram with binwidth but fill determined by price_bin intervals
ggplot(rent_data, aes(x = price_qm2023, fill = price_bin)) +
geom_histogram(binwidth = 100, boundary = 0, closed = "left") +
scale_fill_manual(name = "€ per sqm", values = viridis_colors, drop = FALSE,
guide = guide_legend(reverse = TRUE)) +
scale_x_continuous(breaks = seq(0, max(rent_data$price_qm2023, na.rm = TRUE), by = 1000)) +
labs(title = "Distribution of Sales Prices per sqm across GVBs (2023)",
x = "Price per sqm (€)",
y = "Number of GVBs") +
theme_minimal(base_size = 14) +
theme(panel.grid.minor = element_blank(),
legend.position = "right")
# 5. Plot with discrete bins directly in ggplot
ggplot(hexagons_merged) +
geom_sf(aes(fill = cut(price_qm2023,
breaks = c(500, 1000, 2000, 3000, 4000, 5000, 6000, 8000, 10000, Inf),
labels = c("500–1000", "1000-2000", "2000-3000", "3000-4000",
"4000-5000", "5000-6000", "6000-8000", "8000-10000",
"10000+")))) +
scale_fill_manual(name = "€ per sqm",
values = magma_colors,
drop = FALSE,
guide = guide_legend(reverse = TRUE)) +
labs(title = "Sales prices per sqm in Germany (2023)") +
theme_void() +
theme(legend.position = "right",
plot.title = element_text(hjust = 0.5, size = 16, face = "bold"))
# 1. Read the CSV file with rental data
rent_data <- read_csv(paste0(data_folder, "APPLICATIONS/DATA/OUTPUT/2024/AHS-Index-GVB2022-2024/AHS-Index-PURCH-GVB2022-2024.csv"))
# 2. Read the shapefile (hexagons)
hexagons <- st_read(paste0(data_folder, "APPLICATIONS/SHAPES/GVB/GVB2022-2024.shp"))
# 3. Join using the correct column names (postcodeid in shapefile, postcode_id in CSV)
hexagons_merged <- hexagons %>%
left_join(rent_data, by = c("gvb_id" = "gvb_id"))
# 4. Generate 8 discrete colors from magma palette
viridis_colors <- viridis(9, direction = 1)   # reversed so dark = low values
# Assign colors to bins
bin_labels <- c("500–1000", "1000-2000", "2000-3000", "3000-4000", "4000-5000", "5000-6000", "6000-8000", "8000-10000", "10000+")
names(viridis_colors) <- bin_labels
# 5. Plot with discrete bins directly in ggplot
ggplot(hexagons_merged) +
geom_sf(aes(fill = cut(price_qm2023,
breaks = c(500, 1000, 2000, 3000, 4000, 5000, 6000, 8000, 10000, Inf),
labels = c("500–1000", "1000-2000", "2000-3000", "3000-4000",
"4000-5000", "5000-6000", "6000-8000", "8000-10000",
"10000+")))) +
scale_fill_manual(name = "€ per sqm",
values = magma_colors,
drop = FALSE,
guide = guide_legend(reverse = TRUE)) +
labs(title = "Sales prices per sqm in Germany (2023)") +
theme_void() +
theme(legend.position = "right",
plot.title = element_text(hjust = 0.5, size = 16, face = "bold"))
# 5. Plot with discrete bins directly in ggplot
ggplot(hexagons_merged) +
geom_sf(aes(fill = cut(price_qm2023,
breaks = c(500, 1000, 2000, 3000, 4000, 5000, 6000, 8000, 10000, Inf),
labels = c("500–1000", "1000-2000", "2000-3000", "3000-4000",
"4000-5000", "5000-6000", "6000-8000", "8000-10000",
"10000+")))) +
scale_fill_manual(name = "€ per sqm",
values = viridis_colors,
drop = FALSE,
guide = guide_legend(reverse = TRUE)) +
labs(title = "Sales prices per sqm in Germany (2023)") +
theme_void() +
theme(legend.position = "right",
plot.title = element_text(hjust = 0.5, size = 16, face = "bold"))
# 4. Generate 8 discrete colors from magma palette
viridis_colors <- viridis(9, direction = -1)   # reversed so dark = low values
# Assign colors to bins
bin_labels <- c("500–1000", "1000-2000", "2000-3000", "3000-4000", "4000-5000", "5000-6000", "6000-8000", "8000-10000", "10000+")
names(viridis_colors) <- bin_labels
# 5. Plot with discrete bins directly in ggplot
ggplot(hexagons_merged) +
geom_sf(aes(fill = cut(price_qm2023,
breaks = c(500, 1000, 2000, 3000, 4000, 5000, 6000, 8000, 10000, Inf),
labels = c("500–1000", "1000-2000", "2000-3000", "3000-4000",
"4000-5000", "5000-6000", "6000-8000", "8000-10000",
"10000+")))) +
scale_fill_manual(name = "€ per sqm",
values = viridis_colors,
drop = FALSE,
guide = guide_legend(reverse = TRUE)) +
labs(title = "Sales prices per sqm in Germany (2023)") +
theme_void() +
theme(legend.position = "right",
plot.title = element_text(hjust = 0.5, size = 16, face = "bold"))
ggsave("/Users/saloni/Documents/Github/private-work/wip/germany-sales-price-sqm.svg", width=9,height=9)
# 1. Define your bins and magma colors
bin_breaks <- c(500, 1000, 2000, 3000, 4000, 5000, 6000, 8000, 10000, Inf)
bin_labels <- c("500–1000", "1000-2000", "2000-3000", "3000-4000",
"4000-5000", "5000-6000", "6000-8000", "8000-10000",
"10000+")
viridis_colors <- viridis(10, direction = -1)
names(viridis_colors) <- bin_labels
# 2. Classify observations into bins
rent_data_hist <- rent_data %>%
mutate(price_bin = cut(price_qm2023, breaks = bin_breaks, labels = bin_labels, right = FALSE))
# 3. Plot histogram with binwidth but fill determined by price_bin intervals
ggplot(rent_data_hist, aes(x = price_qm2023, fill = price_bin)) +
geom_histogram(binwidth = 100, boundary = 0, closed = "left") +
scale_fill_manual(name = "€ per sqm", values = viridis_colors, drop = FALSE,
guide = guide_legend(reverse = TRUE)) +
scale_x_continuous(breaks = seq(0, max(rent_data$price_qm2023, na.rm = TRUE), by = 1000)) +
labs(title = "Distribution of Sales Prices per sqm across GVBs (2023)",
x = "Price per sqm (€)",
y = "Number of GVBs") +
theme_minimal(base_size = 14) +
theme(panel.grid.minor = element_blank(),
legend.position = "right")
ggsave("/Users/saloni/Documents/Github/private-work/wip/germany-sales-price-sqm/germany-sales-price-sqm-histogram.svg", width=9,height=9)
ggsave("/Users/saloni/Documents/Github/private-work/wip/germany-sales-prices-sqm/germany-sales-price-sqm-histogram.svg", width=9,height=9)
rent_data %>% filter(price_qm2023 > 10000)
filt <- rent_data %>% filter(price_qm2023 > 10000)
View(filt)
filt <- hexagons_merged %>% filter(price_qm2023 > 10000)
View(filt)
filt <- hexagons_merged %>% filter(price_qm2023 > 10000) %>% select(c(gvb_name, price_qm2023))
filt <- hexagons_merged %>% select(gvb_name == "Hamburg")
filt <- hexagons_merged %>% filter(gvb_name == "Hamburg")
filt <- hexagons_merged %>% filter(gvb_name == "Hamburg") %>% select(c(gvb_name, price_qm2023))
# Load required packages
library(tidyverse)
library(viridis)
data_folder <- "/Users/saloni/Documents/Github/WorksInProgressMagazine/Issue_21/prose/"
sample3_sentences <- read_csv(paste0(data_folder, "avgsentlens_sample3.csv"))
# Load required packages
library(tidyverse)
library(viridis)
data_folder <- "/Users/saloni/Documents/Github/WorksInProgressMagazine/Issue_21/prose/"
sample3_sentences <- read_delim(paste0(data_folder, "avgsentlens_sample3.csv"),
delim = ";",
col_names = TRUE)
# Load required packages
library(tidyverse)
library(viridis)
data_folder <- "/Users/saloni/Documents/Github/WorksInProgressMagazine/Issue_21/prose/"
sample3_sentences <- read_delim(paste0(data_folder, "avgsentlens_sample3.csv"),
delim = ";",
col_names = TRUE)
# Filter the dataset for the two periods
filtered_data <- sample3_sentences %>%
filter((year >= 1820 & year <= 1839) | (year >= 1920 & year <= 1939)) %>%
mutate(period = case_when(
year >= 1820 & year <= 1839 ~ "1820–1839",
year >= 1920 & year <= 1939 ~ "1920–1939"
))
# Create the density plot
ggplot(filtered_data, aes(x = avgsentlen, color = period, fill = period)) +
geom_density(alpha = 0.3) +
labs(
title = "Sentence Length Distribution",
x = "Average Sentence Length",
y = "Density",
color = "Publication Period",
fill = "Publication Period"
) +
theme_minimal()
# Create the density plot
ggplot(filtered_data, aes(x = avgsentlen, color = period, fill = period)) +
geom_density(alpha = 0.3) +
scale_x_continuous(breaks = seq(0, 70, by = 10), limits = c(0, 70)) +
labs(
title = "Sentence Length Distribution",
x = "Average Sentence Length",
y = "Density",
color = "Publication Period",
fill = "Publication Period"
) +
theme_minimal()
ggsave(paste0(data_folder, "sentence_length_density.svg", width = 8, height = 8))
ggsave(paste0(data_folder, "sentence_length_density.svg"), width = 8, height = 8)
summary(sample3_sentences)
# Create 20-year bins and label them
data_decades <- sample3_sentences %>%
filter(year >= 1820 & year < 1940) %>%
mutate(period = cut(
year,
breaks = seq(1820, 1940, by = 20),
labels = c("1820–1839", "1840–1859", "1860–1879",
"1880–1899", "1900–1919", "1920–1939"),
right = FALSE
))
# Plot density curves for each 20-year period
ggplot(data_decades, aes(x = avgsentlen, color = period, fill = period)) +
geom_density(alpha = 0.3) +
scale_x_continuous(breaks = seq(0, 70, by = 10), limits = c(0, 70)) +
labs(
title = "Sentence Length Distribution by 20-Year Period",
x = "Average Sentence Length",
y = "Density",
color = "Publication Period",
fill = "Publication Period"
) +
theme_minimal()
# Plot density curves for each 20-year period
ggplot(data_decades, aes(x = avgsentlen, color = period, fill = period)) +
geom_density(alpha = 0.3) +
scale_x_continuous(breaks = seq(0, 70, by = 10), limits = c(0, 70)) +
scale_color_viridis_d(option = "plasma") +  # or "magma", "inferno", "cividis"
scale_fill_viridis_d(option = "plasma") +
labs(
title = "Sentence Length Distribution by 20-Year Period",
x = "Average Sentence Length",
y = "Density",
color = "Publication Period",
fill = "Publication Period"
) +
theme_minimal()
# Plot density curves for each 20-year period
ggplot(data_decades, aes(x = avgsentlen, color = period, fill = period)) +
geom_density(alpha = 0.3) +
scale_x_continuous(breaks = seq(0, 70, by = 10), limits = c(0, 70)) +
# scale_color_viridis_d(option = "plasma") +  # or "magma", "inferno", "cividis"
scale_fill_viridis_d(option = "plasma") +
labs(
title = "Sentence Length Distribution by 20-Year Period",
x = "Average Sentence Length",
y = "Density",
color = "Publication Period",
fill = "Publication Period"
) +
theme_minimal()
# Plot density curves for each 20-year period
ggplot(data_decades, aes(x = avgsentlen,  fill = period)) +
geom_density(alpha = 0.3) +
scale_x_continuous(breaks = seq(0, 70, by = 10), limits = c(0, 70)) +
# scale_color_viridis_d(option = "plasma") +  # or "magma", "inferno", "cividis"
scale_fill_viridis_d(option = "plasma") +
labs(
title = "Sentence Length Distribution by 20-Year Period",
x = "Average Sentence Length",
y = "Density",
color = "Publication Period",
fill = "Publication Period"
) +
theme_minimal()
# Plot density curves for each 20-year period
ggplot(data_decades, aes(x = avgsentlen, color = NULL, fill = period)) +
geom_density(alpha = 0.3) +
scale_x_continuous(breaks = seq(0, 70, by = 10), limits = c(0, 70)) +
# scale_color_viridis_d(option = "plasma") +  # or "magma", "inferno", "cividis"
scale_fill_viridis_d(option = "plasma") +
labs(
title = "Sentence Length Distribution by 20-Year Period",
x = "Average Sentence Length",
y = "Density",
color = "Publication Period",
fill = "Publication Period"
) +
theme_minimal()
# Plot density curves for each 20-year period
ggplot(data_decades, aes(x = avgsentlen, fill = period)) +
geom_density(alpha = 0.3, aes(color=NULL)) +
scale_x_continuous(breaks = seq(0, 70, by = 10), limits = c(0, 70)) +
# scale_color_viridis_d(option = "plasma") +  # or "magma", "inferno", "cividis"
scale_fill_viridis_d(option = "plasma") +
labs(
title = "Sentence Length Distribution by 20-Year Period",
x = "Average Sentence Length",
y = "Density",
color = "Publication Period",
fill = "Publication Period"
) +
theme_minimal()
ggplot(data_decades, aes(x = avgsentlen, color = period, fill = period)) +
geom_density(alpha = 0.3) +
scale_x_continuous(breaks = seq(0, 70, by = 10), limits = c(0, 70)) +
scale_color_viridis_d(option = "plasma") +  # or "magma", "inferno", "cividis"
scale_fill_viridis_d(option = "plasma") +
labs(
title = "Sentence Length Distribution by 20-Year Period",
x = "Average Sentence Length",
y = "Density",
color = "Publication Period",
fill = "Publication Period"
) +
theme_minimal()
# Plot density curves for each 20-year period
ggplot(data_decades, aes(x = avgsentlen, color = period, fill = period)) +
geom_density(alpha = 0.3) +
scale_x_continuous(breaks = seq(0, 70, by = 10), limits = c(0, 70)) +
scale_color_viridis_d(option = "plasma", direction = -1) +  # or "magma", "inferno", "cividis"
scale_fill_viridis_d(option = "plasma", direction = -1) +
labs(
title = "Sentence Length Distribution by 20-Year Period",
x = "Average Sentence Length",
y = "Density",
color = "Publication Period",
fill = "Publication Period"
) +
theme_minimal()
# Plot density curves for each 20-year period
ggplot(data_decades, aes(x = avgsentlen, color = period, fill = period)) +
geom_density(alpha = 0.3) +
scale_x_continuous(breaks = seq(0, 70, by = 10), limits = c(0, 70)) +
scale_color_viridis_d(direction = -1) +  # or "magma", "inferno", "cividis"
scale_fill_viridis_d(direction = -1) +
labs(
title = "Sentence Length Distribution by 20-Year Period",
x = "Average Sentence Length",
y = "Density",
color = "Publication Period",
fill = "Publication Period"
) +
theme_minimal()
ggsave(paste0(data_folder, "sentence_length_density.svg"), width = 8, height = 8)
library(raster)
library(rayshader)
library(geodata)
library(ggplot2)
library(scales)
countries <- c("CHN", "IND", "NPL", "BTN", "MMR", "THA", "VNM", "LAO", "KHM", "BGD", "LKA", "TWN")
cols <- colorRampPalette(c(
"#08306b",  # dark blue (low elevation)
"#4292c6",  # light blue
"#66c2a4",  # green
"#fdae61",  # yellow-orange
"#f46d43",  # orange
"#f0f0f0"   # white (high elevation)
))(256)
# Download elevation rasters (30 arc-seconds ≈ 1km)
rasters <- lapply(countries, function(code) {
elevation_30s(country = code, path = tempdir())
})
# Merge all into a single raster
asia_dem <- do.call(merge, rasters)
# Crop to a tidy extent (adjust as needed)
asia_crop <- crop(asia_dem, extent(60, 125, 5, 45))
# Replace all negative values with 0
asia_crop[asia_crop < 0] <- 0
# Example: Reduce size by 4x in both dimensions (16x faster)
lowres <- aggregate(asia_crop, fact = 4, fun = mean)
elev_matrix <- raster_to_matrix(lowres)
# Shade the heightmap (returns an RGB array)
colored <- height_shade(elev_matrix, texture = cols)
# Now render 3D with plot_3d
# NORTH AT TOP: Use theta = 0 and phi = 90 (straight down) for map-style orientation
plot_3d(
colored,
heightmap = elev_matrix,
zscale = 20,       # Increase for more "height"
fov = 0,           # Orthographic projection
theta = 0,         # Looking from the top (north is up)
phi = 70,          # Directly overhead
zoom = 0.7,
shadow = FALSE,
windowsize = c(700, 500),
background = "white"
)
# Save output
render_snapshot("tibetan-plateau-output.png")
# Dynaimcally set window height and width based on object size
w <- nrow(colored)
h <- ncol(colored)
# Scale the dimensions so we can use them as multipliers
wr <- w / max(c(w,h))
hr <- h / max(c(w,h))
# Limit ratio so that the shorter side is at least .75 of longer side
if (min(c(wr, hr)) < .75) {
if (wr < .75) {
wr <- .75
} else {
hr <- .75
}
}
# Save output
render_snapshot("tibetan-plateau-output.png")
# Now render 3D with plot_3d
# NORTH AT TOP: Use theta = 0 and phi = 90 (straight down) for map-style orientation
tibet_shade <- plot_3d(
colored,
heightmap = elev_matrix,
zscale = 20,       # Increase for more "height"
fov = 0,           # Orthographic projection
theta = 0,         # Looking from the top (north is up)
phi = 70,          # Directly overhead
zoom = 0.7,
shadow = FALSE,
windowsize = c(700, 500),
background = "white"
)
save_png(tibet_shade, "tibetan-plateau-output1.png")
save_png(colored, "tibetan-plateau-output1.png")
save_3dprint("tibetan-plateau-output1.png")
render_highquality("tibetan-plateau-output_hd.png",
lightdirection = c(0),
title_bar_color="white",
title_bar_alpha=0.8,
min_variance = 0,
sample_method = "sobol_blue")
# Now render 3D with plot_3d
# NORTH AT TOP: Use theta = 0 and phi = 90 (straight down) for map-style orientation
tibet_shade <- plot_3d(
colored,
heightmap = elev_matrix,
zscale = 10,       # Increase for more "height"
fov = 0,           # Orthographic projection
theta = 0,         # Looking from the top (north is up)
phi = 70,          # Directly overhead
zoom = 0.7,
shadow = FALSE,
windowsize = c(700, 500),
background = "transparent"
)
save_png("tibetan-plateau-output1.png") # not 3D
# Save output
render_snapshot("tibetan-plateau-output.png") # 3D but low res
### HIGH RES RENDER
# Dynaimcally set window height and width based on object size
w <- nrow(colored)
h <- ncol(colored)
# Scale the dimensions so we can use them as multipliers
wr <- w / max(c(w,h))
hr <- h / max(c(w,h))
# Limit ratio so that the shorter side is at least .75 of longer side
if (min(c(wr, hr)) < .75) {
if (wr < .75) {
wr <- .75
} else {
hr <- .75
}
}
render_highquality("tibetan-plateau-output_hd.png",
lightdirection = c(0),
light = TRUE,
lightcolor = "white",
title_bar_color="white",
title_bar_alpha=0.8,
min_variance = 0,
sample_method = "sobol_blue")
render_highquality("tibetan-plateau-output_hd.png",
light = TRUE,
lightcolor = "white",
samples = 180,
sample_method = "sobol")
